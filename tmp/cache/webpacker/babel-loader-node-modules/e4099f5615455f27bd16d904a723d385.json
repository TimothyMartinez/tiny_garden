{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = serverRenderReactComponent;\n\nvar _stringify = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/json/stringify\"));\n\nvar _server = _interopRequireDefault(require(\"react-dom/server\"));\n\nvar _ComponentRegistry = _interopRequireDefault(require(\"./ComponentRegistry\"));\n\nvar _createReactElement = _interopRequireDefault(require(\"./createReactElement\"));\n\nvar _isCreateReactElementResultNonReactComponent = _interopRequireDefault(require(\"./isCreateReactElementResultNonReactComponent\"));\n\nvar _buildConsoleReplay = _interopRequireDefault(require(\"./buildConsoleReplay\"));\n\nvar _handleError = _interopRequireDefault(require(\"./handleError\"));\n\nfunction serverRenderReactComponent(options) {\n  var name = options.name,\n      domNodeId = options.domNodeId,\n      trace = options.trace,\n      props = options.props,\n      railsContext = options.railsContext;\n  var htmlResult = '';\n  var hasErrors = false;\n\n  try {\n    var componentObj = _ComponentRegistry[\"default\"].get(name);\n\n    if (componentObj.isRenderer) {\n      throw new Error(\"Detected a renderer while server rendering component '\".concat(name, \"'. See https://github.com/shakacode/react_on_rails#renderer-functions\"));\n    }\n\n    var reactElementOrRouterResult = (0, _createReactElement[\"default\"])({\n      componentObj: componentObj,\n      domNodeId: domNodeId,\n      trace: trace,\n      props: props,\n      railsContext: railsContext\n    });\n\n    if ((0, _isCreateReactElementResultNonReactComponent[\"default\"])(reactElementOrRouterResult)) {\n      // We let the client side handle any redirect\n      // Set hasErrors in case we want to throw a Rails exception\n      hasErrors = !!reactElementOrRouterResult.routeError;\n\n      if (hasErrors) {\n        console.error(\"React Router ERROR: \".concat((0, _stringify[\"default\"])(reactElementOrRouterResult.routeError)));\n      }\n\n      if (reactElementOrRouterResult.redirectLocation) {\n        if (trace) {\n          var redirectLocation = reactElementOrRouterResult.redirectLocation;\n          var redirectPath = redirectLocation.pathname + redirectLocation.search;\n          console.log(\"ROUTER REDIRECT: \".concat(name, \" to dom node with id: \").concat(domNodeId, \", redirect to \").concat(redirectPath));\n        } // For redirects on server rendering, we can't stop Rails from returning the same result.\n        // Possibly, someday, we could have the rails server redirect.\n\n      } else {\n        htmlResult = reactElementOrRouterResult.renderedHtml;\n      }\n    } else {\n      htmlResult = _server[\"default\"].renderToString(reactElementOrRouterResult);\n    }\n  } catch (e) {\n    hasErrors = true;\n    htmlResult = (0, _handleError[\"default\"])({\n      e: e,\n      name: name,\n      serverSide: true\n    });\n  }\n\n  var consoleReplayScript = (0, _buildConsoleReplay[\"default\"])();\n  return (0, _stringify[\"default\"])({\n    html: htmlResult,\n    consoleReplayScript: consoleReplayScript,\n    hasErrors: hasErrors\n  });\n}","map":null,"metadata":{},"sourceType":"module"}