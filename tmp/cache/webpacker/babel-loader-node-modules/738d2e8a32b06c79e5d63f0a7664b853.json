{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.reactOnRailsPageLoaded = reactOnRailsPageLoaded;\nexports.clientStartup = clientStartup;\n\nvar _stringify = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/json/stringify\"));\n\nvar _reactDom = _interopRequireDefault(require(\"react-dom\"));\n\nvar _createReactElement = _interopRequireDefault(require(\"./createReactElement\"));\n\nvar _isCreateReactElementResultNonReactComponent = _interopRequireDefault(require(\"./isCreateReactElementResultNonReactComponent\"));\n/* global ReactOnRails Turbolinks */\n\n\nvar REACT_ON_RAILS_STORE_ATTRIBUTE = 'data-js-react-on-rails-store';\n\nfunction findContext() {\n  if (typeof window.ReactOnRails !== 'undefined') {\n    return window;\n  } else if (typeof ReactOnRails !== 'undefined') {\n    return global;\n  }\n\n  throw new Error(\"ReactOnRails is undefined in both global and window namespaces.\\n  \");\n}\n\nfunction debugTurbolinks() {\n  if (!window) {\n    return;\n  }\n\n  var context = findContext();\n\n  if (context.ReactOnRails.option('traceTurbolinks')) {\n    var _console;\n\n    for (var _len = arguments.length, msg = new Array(_len), _key = 0; _key < _len; _key++) {\n      msg[_key] = arguments[_key];\n    }\n\n    (_console = console).log.apply(_console, ['TURBO:'].concat(msg));\n  }\n}\n\nfunction turbolinksInstalled() {\n  return typeof Turbolinks !== 'undefined';\n}\n\nfunction forEach(fn, className, railsContext) {\n  var els = document.getElementsByClassName(className);\n\n  for (var i = 0; i < els.length; i += 1) {\n    fn(els[i], railsContext);\n  }\n}\n\nfunction forEachByAttribute(fn, attributeName, railsContext) {\n  var els = document.querySelectorAll(\"[\".concat(attributeName, \"]\"));\n\n  for (var i = 0; i < els.length; i += 1) {\n    fn(els[i], railsContext);\n  }\n}\n\nfunction forEachComponent(fn, railsContext) {\n  forEach(fn, 'js-react-on-rails-component', railsContext);\n}\n\nfunction initializeStore(el, railsContext) {\n  var context = findContext();\n  var name = el.getAttribute(REACT_ON_RAILS_STORE_ATTRIBUTE);\n  var props = JSON.parse(el.textContent);\n  var storeGenerator = context.ReactOnRails.getStoreGenerator(name);\n  var store = storeGenerator(props, railsContext);\n  context.ReactOnRails.setStore(name, store);\n}\n\nfunction forEachStore(railsContext) {\n  forEachByAttribute(initializeStore, REACT_ON_RAILS_STORE_ATTRIBUTE, railsContext);\n}\n\nfunction turbolinksVersion5() {\n  return typeof Turbolinks.controller !== 'undefined';\n}\n\nfunction turbolinksSupported() {\n  return Turbolinks.supported;\n}\n\nfunction delegateToRenderer(componentObj, props, railsContext, domNodeId, trace) {\n  var name = componentObj.name,\n      component = componentObj.component,\n      isRenderer = componentObj.isRenderer;\n\n  if (isRenderer) {\n    if (trace) {\n      console.log(\"DELEGATING TO RENDERER \".concat(name, \" for dom node with id: \").concat(domNodeId, \" with props, railsContext:\"), props, railsContext);\n    }\n\n    component(props, railsContext, domNodeId);\n    return true;\n  }\n\n  return false;\n}\n\nfunction domNodeIdForEl(el) {\n  return el.getAttribute('data-dom-id');\n}\n/**\n * Used for client rendering by ReactOnRails. Either calls ReactDOM.hydrate, ReactDOM.render, or\n * delegates to a renderer registered by the user.\n * @param el\n */\n\n\nfunction render(el, railsContext) {\n  var context = findContext(); // This must match lib/react_on_rails/helper.rb\n\n  var name = el.getAttribute('data-component-name');\n  var domNodeId = domNodeIdForEl(el);\n  var props = JSON.parse(el.textContent);\n  var trace = el.getAttribute('data-trace');\n\n  try {\n    var domNode = document.getElementById(domNodeId);\n\n    if (domNode) {\n      var componentObj = context.ReactOnRails.getComponent(name);\n\n      if (delegateToRenderer(componentObj, props, railsContext, domNodeId, trace)) {\n        return;\n      } // Hydrate if available and was server rendered\n\n\n      var shouldHydrate = !!_reactDom[\"default\"].hydrate && !!domNode.innerHTML;\n      var reactElementOrRouterResult = (0, _createReactElement[\"default\"])({\n        componentObj: componentObj,\n        props: props,\n        domNodeId: domNodeId,\n        trace: trace,\n        railsContext: railsContext,\n        shouldHydrate: shouldHydrate\n      });\n\n      if ((0, _isCreateReactElementResultNonReactComponent[\"default\"])(reactElementOrRouterResult)) {\n        throw new Error(\"You returned a server side type of react-router error: \".concat((0, _stringify[\"default\"])(reactElementOrRouterResult), \"\\nYou should return a React.Component always for the client side entry point.\"));\n      } else if (shouldHydrate) {\n        _reactDom[\"default\"].hydrate(reactElementOrRouterResult, domNode);\n      } else {\n        _reactDom[\"default\"].render(reactElementOrRouterResult, domNode);\n      }\n    }\n  } catch (e) {\n    e.message = \"ReactOnRails encountered an error while rendering component: \".concat(name, \".\\n\") + \"Original message: \".concat(e.message);\n    throw e;\n  }\n}\n\nfunction parseRailsContext() {\n  var el = document.getElementById('js-react-on-rails-context');\n\n  if (el) {\n    return JSON.parse(el.textContent);\n  }\n\n  return null;\n}\n\nfunction reactOnRailsPageLoaded() {\n  debugTurbolinks('reactOnRailsPageLoaded');\n  var railsContext = parseRailsContext();\n  forEachStore(railsContext);\n  forEachComponent(render, railsContext);\n}\n\nfunction unmount(el) {\n  var domNodeId = domNodeIdForEl(el);\n  var domNode = document.getElementById(domNodeId);\n\n  try {\n    _reactDom[\"default\"].unmountComponentAtNode(domNode);\n  } catch (e) {\n    console.info(\"Caught error calling unmountComponentAtNode: \".concat(e.message, \" for domNode\"), domNode, e);\n  }\n}\n\nfunction reactOnRailsPageUnloaded() {\n  debugTurbolinks('reactOnRailsPageUnloaded');\n  forEachComponent(unmount);\n}\n\nfunction renderInit() {\n  // Install listeners when running on the client (browser).\n  // We must do this check for turbolinks AFTER the document is loaded because we load the\n  // Webpack bundles first.\n  if (!turbolinksInstalled() || !turbolinksSupported()) {\n    debugTurbolinks('NOT USING TURBOLINKS: calling reactOnRailsPageLoaded');\n    reactOnRailsPageLoaded();\n    return;\n  }\n\n  if (turbolinksVersion5()) {\n    debugTurbolinks('USING TURBOLINKS 5: document added event listeners ' + 'turbolinks:before-render and turbolinks:render.');\n    document.addEventListener('turbolinks:before-render', reactOnRailsPageUnloaded);\n    document.addEventListener('turbolinks:render', reactOnRailsPageLoaded);\n    reactOnRailsPageLoaded();\n  } else {\n    debugTurbolinks('USING TURBOLINKS 2: document added event listeners page:before-unload and ' + 'page:change.');\n    document.addEventListener('page:before-unload', reactOnRailsPageUnloaded);\n    document.addEventListener('page:change', reactOnRailsPageLoaded);\n  }\n}\n\nfunction clientStartup(context) {\n  var document = context.document; // Check if server rendering\n\n  if (!document) {\n    return;\n  } // Tried with a file local variable, but the install handler gets called twice.\n  // eslint-disable-next-line no-underscore-dangle\n\n\n  if (context.__REACT_ON_RAILS_EVENT_HANDLERS_RAN_ONCE__) {\n    return;\n  } // eslint-disable-next-line no-underscore-dangle, no-param-reassign\n\n\n  context.__REACT_ON_RAILS_EVENT_HANDLERS_RAN_ONCE__ = true;\n  debugTurbolinks('Adding DOMContentLoaded event to install event listeners.');\n\n  if (document.readyState === 'complete') {\n    window.setTimeout(renderInit);\n  } else {\n    document.addEventListener('DOMContentLoaded', renderInit);\n  }\n}","map":null,"metadata":{},"sourceType":"module"}